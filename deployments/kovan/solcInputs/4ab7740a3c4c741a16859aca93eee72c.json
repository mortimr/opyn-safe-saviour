{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/CollateralJoinLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract CollateralJoinLike {\n    function safeEngine() public view virtual returns (address);\n\n    function collateralType() public view virtual returns (bytes32);\n\n    function collateral() public view virtual returns (address);\n\n    function decimals() public view virtual returns (uint256);\n\n    function contractEnabled() public view virtual returns (uint256);\n\n    function join(address, uint256) external virtual;\n}\n"
    },
    "contracts/test-utils/CollateralJoinMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/CollateralJoinLike.sol';\n\ncontract CollateralJoinMock is CollateralJoinLike {\n    address private _safeEngine;\n    bytes32 private _collateralType;\n    address private _collateral;\n    uint256 private _decimals;\n    uint256 private _contractEnabled;\n\n    constructor(\n        address __safeEngine,\n        bytes32 __collateralType,\n        address __collateral,\n        uint256 __decimals,\n        uint256 __contractEnabled\n    ) {\n        _safeEngine = __safeEngine;\n        _collateralType = __collateralType;\n        _collateral = __collateral;\n        _decimals = __decimals;\n        _contractEnabled = __contractEnabled;\n    }\n\n    function safeEngine() public view override returns (address) {\n        return _safeEngine;\n    }\n\n    function collateralType() public view override returns (bytes32) {\n        return _collateralType;\n    }\n\n    function collateral() public view override returns (address) {\n        return _collateral;\n    }\n\n    function decimals() public view override returns (uint256) {\n        return _decimals;\n    }\n\n    function contractEnabled() public view override returns (uint256) {\n        return _contractEnabled;\n    }\n\n    function join(address owner, uint256 amount) external override {\n        // well guess it does nothing special during tests\n    }\n}\n"
    },
    "contracts/interfaces/SafeSaviourLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport './CollateralJoinLike.sol';\nimport './OracleRelayerLike.sol';\nimport './SAFEEngineLike.sol';\nimport './LiquidationEngineLike.sol';\nimport './PriceFeedLike.sol';\nimport './ERC20Like.sol';\nimport './GebSafeManagerLike.sol';\nimport './SAFESaviourRegistryLike.sol';\n\nimport '../utils/ReentrancyGuard.sol';\n\nabstract contract SafeSaviourLike is ReentrancyGuard {\n    // --- Variables ---\n    LiquidationEngineLike public liquidationEngine;\n    OracleRelayerLike public oracleRelayer;\n    GebSafeManagerLike public safeManager;\n    SAFEEngineLike public safeEngine;\n    SAFESaviourRegistryLike public saviourRegistry;\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    // The amount of tokens the keeper gets in exchange for the gas spent to save a SAFE\n    uint256 public keeperPayout; // [wad]\n    // The minimum fiat value that the keeper must get in exchange for saving a SAFE\n    uint256 public minKeeperPayoutValue; // [wad]\n    /*\n      The proportion between the keeperPayout (if it's in collateral) and the amount of collateral that's in a SAFE to be saved.\n      Alternatively, it can be the proportion between the fiat value of keeperPayout and the fiat value of the profit that a keeper\n      could make if a SAFE is liquidated right now. It ensures there's no incentive to intentionally put a SAFE underwater and then\n      save it just to make a profit that's greater than the one from participating in collateral auctions\n    */\n    uint256 public payoutToSAFESize;\n    // The default collateralization ratio a SAFE should have after it's saved\n    uint256 public defaultDesiredCollateralizationRatio; // [percentage]\n\n    // Desired CRatios for each SAFE after they're saved\n    mapping(bytes32 => mapping(address => uint256)) public desiredCollateralizationRatios;\n\n    // --- Constants ---\n    uint256 public constant ONE = 1;\n    uint256 public constant HUNDRED = 100;\n    uint256 public constant THOUSAND = 1000;\n    uint256 public constant CRATIO_SCALE_DOWN = 10**25;\n    uint256 public constant WAD_COMPLEMENT = 10**9;\n    uint256 public constant WAD = 10**18;\n    uint256 public constant RAY = 10**27;\n    uint256 public constant MAX_CRATIO = 1000;\n    uint256 public constant MAX_UINT = uint256(-1);\n\n    // --- Events ---\n    event SetDesiredCollateralizationRatio(\n        address indexed caller,\n        uint256 indexed safeID,\n        address indexed safeHandler,\n        uint256 cRatio\n    );\n    event SaveSAFE(\n        address indexed keeper,\n        bytes32 indexed collateralType,\n        address indexed safeHandler,\n        uint256 collateralAddedOrDebtRepaid\n    );\n\n    // --- Functions to Implement ---\n    function saveSAFE(\n        address,\n        bytes32,\n        address\n    )\n        external\n        virtual\n        returns (\n            bool,\n            uint256,\n            uint256\n        );\n\n    function getKeeperPayoutValue() public virtual returns (uint256);\n\n    function keeperPayoutExceedsMinValue() public virtual returns (bool);\n\n    function canSave(address) external virtual returns (bool);\n\n    function tokenAmountUsedToSave(address) public virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/OracleRelayerLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract OracleRelayerLike {\n    function collateralTypes(bytes32)\n        public\n        view\n        virtual\n        returns (\n            address,\n            uint256,\n            uint256\n        );\n\n    function liquidationCRatio(bytes32) public view virtual returns (uint256);\n\n    function redemptionPrice() public virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/SAFEEngineLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract SAFEEngineLike {\n    function safeRights(address, address) public view virtual returns (uint256);\n\n    function collateralTypes(bytes32)\n        public\n        view\n        virtual\n        returns (\n            uint256 debtAmount, // [wad]\n            uint256 accumulatedRate, // [ray]\n            uint256 safetyPrice, // [ray]\n            uint256 debtCeiling, // [rad]\n            uint256 debtFloor, // [rad]\n            uint256 liquidationPrice // [ray]\n        );\n\n    function safes(bytes32, address)\n        public\n        view\n        virtual\n        returns (\n            uint256 lockedCollateral, // [wad]\n            uint256 generatedDebt // [wad]\n        );\n\n    function modifySAFECollateralization(\n        bytes32 collateralType,\n        address safe,\n        address collateralSource,\n        address debtDestination,\n        int256 deltaCollateral, // [wad]\n        int256 deltaDebt // [wad]\n    ) external virtual;\n}\n"
    },
    "contracts/interfaces/LiquidationEngineLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract LiquidationEngineLike {\n    function safeSaviours(address) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/PriceFeedLike.sol": {
      "content": "// Copyright (C) 2020 Reflexer Labs, INC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract PriceFeedLike {\n    function priceSource() public view virtual returns (address);\n\n    function getResultWithValidity() external view virtual returns (uint256, bool);\n}\n"
    },
    "contracts/interfaces/ERC20Like.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract ERC20Like {\n    uint256 public totalSupply;\n\n    function balanceOf(address guy) public virtual returns (uint256);\n\n    function approve(address guy, uint256 wad) public virtual returns (bool);\n\n    function transfer(address dst, uint256 wad) public virtual returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool);\n}\n"
    },
    "contracts/interfaces/GebSafeManagerLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract GebSafeManagerLike {\n    function safes(uint256) public view virtual returns (address);\n\n    function ownsSAFE(uint256) public view virtual returns (address);\n\n    function safeCan(\n        address,\n        uint256,\n        address\n    ) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/SAFESaviourRegistryLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract SAFESaviourRegistryLike {\n    mapping(address => uint256) public authorizedAccounts;\n\n    function markSave(bytes32 collateralType, address safeHandler) external virtual;\n}\n"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/test-utils/LiquidationEngineMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/LiquidationEngineLike.sol';\nimport '../interfaces/SafeSaviourLike.sol';\n\ncontract LiquidationEngineMock is LiquidationEngineLike {\n    mapping(address => uint256) public _safeSaviours;\n\n    function toggleSafeSaviour(address saviour) public {\n        _safeSaviours[saviour] = (_safeSaviours[saviour] + 1) % 2;\n    }\n\n    function safeSaviours(address safe) public view override returns (uint256) {\n        return _safeSaviours[safe];\n    }\n\n    function fakeLiquidateSAFE(\n        address keeper,\n        bytes32 collateralType,\n        address safe,\n        address saviour\n    )\n        public\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        return SafeSaviourLike(saviour).saveSAFE(keeper, collateralType, safe);\n    }\n\n    function fakeInitCall(address saviour) public {\n        (bool status, uint256 collateralAdded, uint256 keeperPayout) =\n            SafeSaviourLike(saviour).saveSAFE(address(this), '', address(0));\n        require(status == true, 'invalid status');\n        require(collateralAdded == uint256(-1), 'invalid collateral added');\n        require(keeperPayout == uint256(-1), 'invalid keeper payout');\n    }\n}\n"
    },
    "contracts/test-utils/Asserter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/SafeSaviourLike.sol';\n\ncontract Asserter {\n    function testCanSave(\n        address saviour,\n        address safeHandler,\n        bool expectedValue\n    ) public {\n        require(SafeSaviourLike(saviour).canSave(safeHandler) == expectedValue, 'expected value not received');\n    }\n\n    function testTokenAmountUsedToSave(\n        address saviour,\n        address safeHandler,\n        uint256 expectedValue\n    ) public {\n        require(\n            SafeSaviourLike(saviour).tokenAmountUsedToSave(safeHandler) == expectedValue,\n            'expected value not received'\n        );\n    }\n}\n"
    },
    "contracts/saviours/OpynSafeSaviour.sol": {
      "content": "// Copyright (C) 2020 Reflexer Labs, INC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.8.2;\n\nimport '../interfaces/SafeSaviourLike.sol';\nimport './OpynSafeSaviourOperator.sol';\nimport '../math/SafeMath.sol';\n\ncontract OpynSafeSaviour is SafeMath, SafeSaviourLike {\n    // --- Variables ---\n    // Amount of collateral deposited to cover each SAFE\n    mapping(address => uint256) public oTokenCover;\n    // oToken type selected by each SAFE\n    mapping(address => address) public oTokenSelection;\n    // The collateral join contract for adding collateral in the system\n    CollateralJoinLike public collateralJoin;\n    // The collateral token\n    ERC20Like public collateralToken;\n    // Operator handling all the Opyn logic\n    OpynSafeSaviourOperator public opynSafeSaviourOperator;\n\n    // Checks whether a saviour contract has been approved by governance in the LiquidationEngine\n    modifier liquidationEngineApproved(address saviour) {\n        require(liquidationEngine.safeSaviours(saviour) == 1, 'SafeSaviour/not-approved-in-liquidation-engine');\n        _;\n    }\n    // Checks whether someone controls a safe handler inside the GebSafeManager\n    modifier controlsSAFE(address owner, uint256 safeID) {\n        require(owner != address(0), 'SafeSaviour/null-owner');\n        require(\n            either(\n                owner == safeManager.ownsSAFE(safeID),\n                safeManager.safeCan(safeManager.ownsSAFE(safeID), safeID, owner) == 1\n            ),\n            'SafeSaviour/not-owning-safe'\n        );\n\n        _;\n    }\n\n    // --- Events ---\n    event Deposit(address indexed caller, address indexed safeHandler, uint256 amount);\n    event Withdraw(address indexed caller, uint256 indexed safeID, address indexed safeHandler, uint256 amount);\n\n    constructor(\n        address _collateralJoin,\n        address _liquidationEngine,\n        address _oracleRelayer,\n        address _safeManager,\n        address _saviourRegistry,\n        address _opynSafeSaviourOperator,\n        uint256 _keeperPayout,\n        uint256 _minKeeperPayoutValue,\n        uint256 _payoutToSAFESize,\n        uint256 _defaultDesiredCollateralizationRatio\n    ) {\n        require(_collateralJoin != address(0), 'OpynSafeSaviour/null-collateral-join');\n        require(_liquidationEngine != address(0), 'OpynSafeSaviour/null-liquidation-engine');\n        require(_oracleRelayer != address(0), 'OpynSafeSaviour/null-oracle-relayer');\n        require(_safeManager != address(0), 'OpynSafeSaviour/null-safe-manager');\n        require(_saviourRegistry != address(0), 'OpynSafeSaviour/null-saviour-registry');\n        require(_opynSafeSaviourOperator != address(0), 'OpynSafeSaviour/null-opyn-safe-saviour-operator');\n        require(_keeperPayout > 0, 'OpynSafeSaviour/invalid-keeper-payout');\n        require(_minKeeperPayoutValue > 0, 'OpynSafeSaviour/invalid-min-payout-value');\n        require(_payoutToSAFESize > 1, 'OpynSafeSaviour/invalid-payout-to-safe-size');\n        require(_defaultDesiredCollateralizationRatio > 0, 'OpynSafeSaviour/null-default-cratio');\n\n        keeperPayout = _keeperPayout;\n        payoutToSAFESize = _payoutToSAFESize;\n        minKeeperPayoutValue = _minKeeperPayoutValue;\n\n        liquidationEngine = LiquidationEngineLike(_liquidationEngine);\n        collateralJoin = CollateralJoinLike(_collateralJoin);\n        oracleRelayer = OracleRelayerLike(_oracleRelayer);\n        safeEngine = SAFEEngineLike(collateralJoin.safeEngine());\n        safeManager = GebSafeManagerLike(_safeManager);\n        saviourRegistry = SAFESaviourRegistryLike(_saviourRegistry);\n        collateralToken = ERC20Like(collateralJoin.collateral());\n        opynSafeSaviourOperator = OpynSafeSaviourOperator(_opynSafeSaviourOperator);\n\n        require(address(safeEngine) != address(0), 'OpynSafeSaviour/null-safe-engine');\n\n        uint256 scaledLiquidationRatio =\n            oracleRelayer.liquidationCRatio(collateralJoin.collateralType()) / CRATIO_SCALE_DOWN;\n        require(scaledLiquidationRatio > 0, 'OpynSafeSaviour/invalid-scaled-liq-ratio');\n        require(\n            both(\n                _defaultDesiredCollateralizationRatio > scaledLiquidationRatio,\n                _defaultDesiredCollateralizationRatio <= MAX_CRATIO\n            ),\n            'OpynSafeSaviour/invalid-default-desired-cratio'\n        );\n\n        require(collateralJoin.decimals() == 18, 'OpynSafeSaviour/invalid-join-decimals');\n        require(collateralJoin.contractEnabled() == 1, 'OpynSafeSaviour/join-disabled');\n\n        defaultDesiredCollateralizationRatio = _defaultDesiredCollateralizationRatio;\n    }\n\n    // --- Adding/Withdrawing Cover ---\n    /*\n     * @notice Deposit oToken in the contract in order to provide cover for a specific SAFE controlled by the SAFE Manager\n     * @param safeID The ID of the SAFE to protect. This ID should be registered inside GebSafeManager\n     * @param oTokenAmount The amount of oToken to deposit\n     * @param oTokenType the address of the erc20 contract controlling the oTokens\n     */\n    function deposit(\n        uint256 _safeID,\n        uint256 _oTokenAmount,\n        address _oTokenType\n    ) external liquidationEngineApproved(address(this)) controlsSAFE(msg.sender, _safeID) nonReentrant {\n        require(_oTokenAmount > 0, 'OpynSafeSaviour/null-oToken-amount');\n        // Check that oToken has been whitelisted by a SaviourRegistry authorized account\n        require(opynSafeSaviourOperator.oTokenWhitelist(_oTokenType) == true, 'OpynSafeSaviour/forbidden-otoken');\n\n        // Check that the SAFE exists inside GebSafeManager\n        address safeHandler = safeManager.safes(_safeID);\n        require(safeHandler != address(0), 'OpynSafeSaviour/null-handler');\n\n        // Check that safe is either protected by provided oToken type or no type at all\n        require(\n            either(oTokenSelection[safeHandler] == _oTokenType, oTokenSelection[safeHandler] == address(0)),\n            'OpynSafeSaviour/safe-otoken-incompatibility'\n        );\n\n        // Check that the SAFE has debt\n        (, uint256 safeDebt) =\n            SAFEEngineLike(collateralJoin.safeEngine()).safes(collateralJoin.collateralType(), safeHandler);\n        require(safeDebt > 0, 'OpynSafeSaviour/safe-does-not-have-debt');\n\n        // Trigger transfer from oToken contract\n        require(\n            ERC20Like(_oTokenType).transferFrom(msg.sender, address(this), _oTokenAmount),\n            'OpynSafeSaviour/could-not-transfer-collateralToken'\n        );\n        // Update the collateralToken balance used to cover the SAFE and transfer collateralToken to this contract\n        oTokenCover[safeHandler] = add(oTokenCover[safeHandler], _oTokenAmount);\n\n        // Check if SAFE oToken selection should be changed\n        if (oTokenSelection[safeHandler] == address(0)) {\n            oTokenSelection[safeHandler] = _oTokenType;\n        }\n\n        emit Deposit(msg.sender, safeHandler, _oTokenAmount);\n    }\n\n    /*\n     * @notice Withdraw oToken from the contract and provide less cover for a SAFE\n     * @dev Only an address that controls the SAFE inside GebSafeManager can call this\n     * @param safeID The ID of the SAFE to remove cover from. This ID should be registered inside GebSafeManager\n     * @param oTokenAmount The amount of oToken to withdraw\n     */\n    function withdraw(uint256 _safeID, uint256 _oTokenAmount) external controlsSAFE(msg.sender, _safeID) nonReentrant {\n        require(_oTokenAmount > 0, 'OpynSafeSaviour/null-collateralToken-amount');\n\n        // Fetch the handler from the SAFE manager\n        address safeHandler = safeManager.safes(_safeID);\n        require(oTokenCover[safeHandler] >= _oTokenAmount, 'OpynSafeSaviour/not-enough-to-withdraw');\n\n        // Withdraw cover and transfer collateralToken to the caller\n        oTokenCover[safeHandler] = sub(oTokenCover[safeHandler], _oTokenAmount);\n        ERC20Like(oTokenSelection[safeHandler]).transfer(msg.sender, _oTokenAmount);\n\n        // Check if balance of selected token\n        if (oTokenCover[safeHandler] == 0) {\n            oTokenSelection[safeHandler] = address(0);\n        }\n\n        emit Withdraw(msg.sender, _safeID, safeHandler, _oTokenAmount);\n    }\n\n    // --- Adjust Cover Preferences ---\n    /*\n     * @notice Sets the collateralization ratio that a SAFE should have after it's saved\n     * @dev Only an address that controls the SAFE inside GebSafeManager can call this\n     * @param safeID The ID of the SAFE to set the desired CRatio for. This ID should be registered inside GebSafeManager\n     * @param cRatio The collateralization ratio to set\n     */\n    function setDesiredCollateralizationRatio(uint256 _safeID, uint256 _cRatio)\n        external\n        controlsSAFE(msg.sender, _safeID)\n    {\n        uint256 scaledLiquidationRatio =\n            oracleRelayer.liquidationCRatio(collateralJoin.collateralType()) / CRATIO_SCALE_DOWN;\n        address safeHandler = safeManager.safes(_safeID);\n\n        require(scaledLiquidationRatio > 0, 'OpynSafeSaviour/invalid-scaled-liq-ratio');\n        require(scaledLiquidationRatio < _cRatio, 'OpynSafeSaviour/invalid-desired-cratio');\n        require(_cRatio <= MAX_CRATIO, 'OpynSafeSaviour/exceeds-max-cratio');\n\n        desiredCollateralizationRatios[collateralJoin.collateralType()][safeHandler] = _cRatio;\n\n        emit SetDesiredCollateralizationRatio(msg.sender, _safeID, safeHandler, _cRatio);\n    }\n\n    // --- Saving Logic ---\n    /*\n     * @notice Saves a SAFE by adding more collateralToken into it\n     * @dev Only the LiquidationEngine can call this\n     * @param keeper The keeper that called LiquidationEngine.liquidateSAFE and that should be rewarded for spending gas to save a SAFE\n     * @param collateralType The collateral type backing the SAFE that's being liquidated\n     * @param safeHandler The handler of the SAFE that's being saved\n     * @return Whether the SAFE has been saved, the amount of collateralToken added in the SAFE as well as the amount of\n     *         collateralToken sent to the keeper as their payment\n     */\n    function saveSAFE(\n        address _keeper,\n        bytes32 _collateralType,\n        address _safeHandler\n    )\n        external\n        override\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        require(address(liquidationEngine) == msg.sender, 'OpynSafeSaviour/caller-not-liquidation-engine');\n        require(_keeper != address(0), 'OpynSafeSaviour/null-keeper-address');\n\n        if (both(both(_collateralType == '', _safeHandler == address(0)), _keeper == address(liquidationEngine))) {\n            return (true, MAX_UINT, MAX_UINT);\n        }\n\n        require(_collateralType == collateralJoin.collateralType(), 'OpynSafeSaviour/invalid-collateral-type');\n        require(oTokenSelection[_safeHandler] != address(0), 'OpynSafeSaviour/no-selected-otoken');\n\n        // Check that the fiat value of the keeper payout is high enough\n        require(keeperPayoutExceedsMinValue(), 'OpynSafeSaviour/small-keeper-payout-value');\n\n        // Compute the amount of collateral that should be added to bring the safe to desired collateral ratio\n        uint256 tokenAmountUsed = tokenAmountUsedToSave(_safeHandler);\n\n        {\n            // Stack too deep guard\n\n            // Check that the amount of collateral locked in the safe is bigger than the keeper's payout\n            (uint256 safeLockedCollateral, ) =\n                SAFEEngineLike(collateralJoin.safeEngine()).safes(collateralJoin.collateralType(), _safeHandler);\n            require(safeLockedCollateral >= mul(keeperPayout, payoutToSAFESize), 'OpynSafeSaviour/tiny-safe');\n        }\n\n        // Compute and check the validity of the amount of collateralToken used to save the SAFE\n        require(both(tokenAmountUsed != MAX_UINT, tokenAmountUsed != 0), 'OpynSafeSaviour/invalid-tokens-used-to-save');\n\n        // The actual required collateral to provide is the sum of what is needed to bring the safe to its desired collateral ratio + the keeper reward\n        uint256 requiredTokenAmount = add(keeperPayout, tokenAmountUsed);\n\n        uint256 oTokenToApprove =\n            opynSafeSaviourOperator.getOTokenAmountToApprove(\n                oTokenSelection[_safeHandler],\n                requiredTokenAmount,\n                address(collateralToken)\n            );\n\n        require(oTokenCover[_safeHandler] >= oTokenToApprove, 'OpynSafeSaviour/otoken-balance-too-low');\n\n        ERC20Like(oTokenSelection[_safeHandler]).approve(address(opynSafeSaviourOperator), oTokenToApprove);\n\n        uint256 initialAmount = collateralToken.balanceOf(address(this));\n\n        opynSafeSaviourOperator.redeemAndSwapOTokens(\n            oTokenSelection[_safeHandler],\n            oTokenToApprove,\n            requiredTokenAmount,\n            address(collateralToken)\n        );\n\n        uint256 receivedCollateralAmount = sub(collateralToken.balanceOf(address(this)), initialAmount);\n        oTokenCover[_safeHandler] = sub(oTokenCover[_safeHandler], oTokenToApprove);\n\n        // Check that balance has increased of at least required amount\n        // This should never get triggered but is the ultimate check to ensure that the Safe Saviour Operator did its job properly\n        require(\n            receivedCollateralAmount >= requiredTokenAmount,\n            'OpynSafeSaviour/not-enough-otoken-collateral-swapped'\n        );\n\n        saviourRegistry.markSave(_collateralType, _safeHandler);\n\n        // Approve collateralToken to the collateral join contract\n        collateralToken.approve(address(collateralJoin), 0);\n        collateralToken.approve(address(collateralJoin), tokenAmountUsed);\n\n        // Join collateralToken in the system and add it in the saved SAFE\n        collateralJoin.join(address(this), tokenAmountUsed);\n        safeEngine.modifySAFECollateralization(\n            collateralJoin.collateralType(),\n            _safeHandler,\n            address(this),\n            address(0),\n            int256(tokenAmountUsed),\n            int256(0)\n        );\n\n        // Send the fee to the keeper, the prize is recomputed to prevent dust\n        collateralToken.transfer(_keeper, sub(receivedCollateralAmount, tokenAmountUsed));\n\n        // Emit an event\n        emit SaveSAFE(_keeper, _collateralType, _safeHandler, tokenAmountUsed);\n\n        return (true, tokenAmountUsed, keeperPayout);\n    }\n\n    // --- Getters ---\n    /*\n     * @notice Compute whether the value of keeperPayout collateralToken is higher than or equal to minKeeperPayoutValue\n     * @dev Used to determine whether it's worth it for the keeper to save the SAFE in exchange for keeperPayout collateralToken\n     * @return A bool representing whether the value of keeperPayout collateralToken is >= minKeeperPayoutValue\n     */\n    function keeperPayoutExceedsMinValue() public view override returns (bool) {\n        (address ethFSM, , ) = oracleRelayer.collateralTypes(collateralJoin.collateralType());\n        (uint256 priceFeedValue, bool hasValidValue) =\n            PriceFeedLike(PriceFeedLike(ethFSM).priceSource()).getResultWithValidity();\n\n        if (either(!hasValidValue, priceFeedValue == 0)) {\n            return false;\n        }\n\n        return (minKeeperPayoutValue <= mul(keeperPayout, priceFeedValue) / WAD);\n    }\n\n    /*\n     * @notice Return the current value of the keeper payout\n     */\n    function getKeeperPayoutValue() public view override returns (uint256) {\n        (address ethFSM, , ) = oracleRelayer.collateralTypes(collateralJoin.collateralType());\n        (uint256 priceFeedValue, bool hasValidValue) =\n            PriceFeedLike(PriceFeedLike(ethFSM).priceSource()).getResultWithValidity();\n\n        if (either(!hasValidValue, priceFeedValue == 0)) {\n            return 0;\n        }\n\n        return mul(keeperPayout, priceFeedValue) / WAD;\n    }\n\n    /*\n     * @notice Determine whether a SAFE can be saved with the current amount of collateralToken deposited as cover for it\n     * @param safeHandler The handler of the SAFE which the function takes into account\n     * @return Whether the SAFE can be saved or not\n     */\n    function canSave(address _safeHandler) external override returns (bool) {\n        uint256 tokenAmountUsed = tokenAmountUsedToSave(_safeHandler);\n\n        if (tokenAmountUsed == MAX_UINT) {\n            return false;\n        }\n\n        // Check if oToken balance is not empty\n        if (oTokenCover[_safeHandler] == 0) {\n            return false;\n        }\n\n        // Check that the fiat value of the keeper payout is high enough\n        if (keeperPayoutExceedsMinValue() == false) {\n            return false;\n        }\n\n        // check if safe too small to be saved\n        (uint256 safeLockedCollateral, ) =\n            SAFEEngineLike(collateralJoin.safeEngine()).safes(collateralJoin.collateralType(), _safeHandler);\n        if (safeLockedCollateral < mul(keeperPayout, payoutToSAFESize)) {\n            return false;\n        }\n\n        uint256 oTokenToApprove =\n            opynSafeSaviourOperator.getOTokenAmountToApprove(\n                oTokenSelection[_safeHandler],\n                add(tokenAmountUsed, keeperPayout),\n                address(collateralToken)\n            );\n\n        // Check that owned oTokens are able to redeem enough collateral to save SAFE\n        return (oTokenToApprove <= oTokenCover[_safeHandler]);\n    }\n\n    /*\n     * @notice Calculate the amount of collateralToken used to save a SAFE and bring its CRatio to the desired level\n     * @param safeHandler The handler of the SAFE which the function takes into account\n     * @return The amount of collateralToken used to save the SAFE and bring its CRatio to the desired level\n     */\n    function tokenAmountUsedToSave(address _safeHandler) public override returns (uint256 tokenAmountUsed) {\n        (uint256 depositedcollateralToken, uint256 safeDebt) =\n            SAFEEngineLike(collateralJoin.safeEngine()).safes(collateralJoin.collateralType(), _safeHandler);\n        (address ethFSM, , ) = oracleRelayer.collateralTypes(collateralJoin.collateralType());\n        (uint256 priceFeedValue, bool hasValidValue) = PriceFeedLike(ethFSM).getResultWithValidity();\n\n        // If the SAFE doesn't have debt or if the price feed is faulty, abort\n        if (either(safeDebt == 0, either(priceFeedValue == 0, !hasValidValue))) {\n            tokenAmountUsed = MAX_UINT;\n            return tokenAmountUsed;\n        }\n\n        // Calculate the value of the debt equivalent to the value of the collateralToken that would need to be in the SAFE after it's saved\n        uint256 targetCRatio =\n            (desiredCollateralizationRatios[collateralJoin.collateralType()][_safeHandler] == 0)\n                ? defaultDesiredCollateralizationRatio\n                : desiredCollateralizationRatios[collateralJoin.collateralType()][_safeHandler];\n        uint256 scaledDownDebtValue =\n            mul(add(mul(oracleRelayer.redemptionPrice(), safeDebt) / RAY, ONE), targetCRatio) / HUNDRED;\n\n        // Compute the amount of collateralToken the SAFE needs to get to the desired CRatio\n        uint256 collateralTokenAmountNeeded = mul(scaledDownDebtValue, WAD) / priceFeedValue;\n\n        // If the amount of collateralToken needed is lower than the amount that's currently in the SAFE, return 0\n        if (collateralTokenAmountNeeded <= depositedcollateralToken) {\n            return 0;\n        } else {\n            // Otherwise return the delta\n            return sub(collateralTokenAmountNeeded, depositedcollateralToken);\n        }\n    }\n}\n"
    },
    "contracts/saviours/OpynSafeSaviourOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/OpynV2OTokenLike.sol';\nimport '../interfaces/OpynV2ControllerLike.sol';\nimport '../interfaces/OpynV2WhitelistLike.sol';\nimport '../interfaces/UniswapV2Router02Like.sol';\nimport '../interfaces/SAFESaviourRegistryLike.sol';\nimport '../interfaces/ERC20Like.sol';\nimport '../math/SafeMath.sol';\n\ncontract OpynSafeSaviourOperator is SafeMath {\n    // The Opyn v2 Controller to interact with oTokens\n    OpynV2ControllerLike public opynV2Controller;\n    // The Opyn v2 Whitelist to check oTokens' validity\n    OpynV2WhitelistLike public opynV2Whitelist;\n    // The Uniswap v2 router 02 to swap collaterals\n    UniswapV2Router02Like public uniswapV2Router02;\n    // oToken type selected by each SAFE\n    mapping(address => address) public oTokenSelection;\n    // Entity whitelisting allowed saviours\n    SAFESaviourRegistryLike public saviourRegistry;\n\n    // Events\n    event ToggleOToken(address oToken, uint256 whitelistState);\n\n    constructor(\n        address opynV2Controller_,\n        address opynV2Whitelist_,\n        address uniswapV2Router02_,\n        address saviourRegistry_\n    ) {\n        require(opynV2Controller_ != address(0), 'OpynSafeSaviour/null-opyn-v2-controller');\n        require(opynV2Whitelist_ != address(0), 'OpynSafeSaviour/null-opyn-v2-whitelist');\n        require(uniswapV2Router02_ != address(0), 'OpynSafeSaviour/null-uniswap-v2-router02');\n        require(saviourRegistry_ != address(0), 'OpynSafeSaviour/null-saviour-registry');\n\n        opynV2Controller = OpynV2ControllerLike(opynV2Controller_);\n        opynV2Whitelist = OpynV2WhitelistLike(opynV2Whitelist_);\n        uniswapV2Router02 = UniswapV2Router02Like(uniswapV2Router02_);\n        saviourRegistry = SAFESaviourRegistryLike(saviourRegistry_);\n    }\n\n    function isOTokenPutOption(address _otoken) external view returns (bool) {\n        (, , , , , bool isPut) = OpynV2OTokenLike(_otoken).getOtokenDetails();\n        return isPut;\n    }\n\n    function getOpynPayout(address _otoken, uint256 _amount) external view returns (uint256) {\n        return opynV2Controller.getPayout(_otoken, _amount);\n    }\n\n    modifier isSaviourRegistryAuthorized() {\n        require(saviourRegistry.authorizedAccounts(msg.sender) == 1, 'OpynSafeSaviour/account-not-authorized');\n        _;\n    }\n\n    function redeemAndSwapOTokens(\n        address _otoken,\n        uint256 _amountIn,\n        uint256 _amountOut,\n        address _safeCollateral\n    ) external {\n        ERC20Like(_otoken).transferFrom(msg.sender, address(this), _amountIn);\n\n        (address oTokenCollateral, , , , , ) = OpynV2OTokenLike(_otoken).getOtokenDetails();\n\n        uint256 redeemedOTokenCollateral;\n\n        {\n            // Opyn Redeem\n\n            uint256 preRedeemBalance = ERC20Like(oTokenCollateral).balanceOf(address(this));\n\n            // Build Opyn Action\n            ActionArgs[] memory redeemAction = new ActionArgs[](1);\n            redeemAction[0].actionType = ActionType.Redeem;\n            redeemAction[0].owner = address(0);\n            redeemAction[0].secondAddress = address(this);\n            redeemAction[0].asset = _otoken;\n            redeemAction[0].vaultId = 0;\n            redeemAction[0].amount = _amountIn;\n\n            // Trigger oToken collateral redeem\n            opynV2Controller.operate(redeemAction);\n\n            redeemedOTokenCollateral = sub(ERC20Like(oTokenCollateral).balanceOf(address(this)), preRedeemBalance);\n        }\n\n        uint256 swappedSafeCollateral;\n\n        {\n            // Uniswap swap\n\n            // Retrieve pre-swap WETH balance\n            uint256 safeCollateralBalance = ERC20Like(_safeCollateral).balanceOf(address(this));\n\n            // Path argument for the uniswap router\n            address[] memory path = new address[](2);\n            path[0] = oTokenCollateral;\n            path[1] = _safeCollateral;\n\n            ERC20Like(oTokenCollateral).approve(address(uniswapV2Router02), redeemedOTokenCollateral);\n\n            uniswapV2Router02.swapExactTokensForTokens(\n                redeemedOTokenCollateral,\n                _amountOut,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n            // Retrieve post-swap WETH balance. Would overflow and throw if balance decreased\n            swappedSafeCollateral = sub(ERC20Like(_safeCollateral).balanceOf(address(this)), safeCollateralBalance);\n        }\n\n        ERC20Like(_safeCollateral).transfer(msg.sender, swappedSafeCollateral);\n    }\n\n    function oTokenWhitelist(address _otoken) external view returns (bool) {\n        return opynV2Whitelist.isWhitelistedOtoken(_otoken);\n    }\n\n    function getOTokenAmountToApprove(\n        address _otoken,\n        uint256 _requiredOutputAmount,\n        address _safeCollateralAddress\n    ) external view returns (uint256) {\n        (address oTokenCollateralAddress, , , , , ) = OpynV2OTokenLike(_otoken).getOtokenDetails();\n\n        address[] memory path = new address[](2);\n        path[0] = oTokenCollateralAddress;\n        path[1] = _safeCollateralAddress;\n\n        uint256 oTokenCollateralAmountRequired = uniswapV2Router02.getAmountsIn(_requiredOutputAmount, path)[0];\n\n        uint256 payoutPerToken = opynV2Controller.getPayout(_otoken, 1);\n\n        require(payoutPerToken > 0, 'OpynSafeSaviour/no-collateral-to-redeem');\n\n        uint256 amountToApprove = div(oTokenCollateralAmountRequired, payoutPerToken);\n\n        // Integer division rounds to zero, better ensure we get at least the required amount\n        if (mul(amountToApprove, payoutPerToken) < _requiredOutputAmount) {\n            amountToApprove += 1;\n        }\n\n        return amountToApprove;\n    }\n}\n"
    },
    "contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\ncontract SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'SafeMath: addition overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, 'SafeMath: subtraction overflow');\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, 'SafeMath: multiplication overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, 'SafeMath: division by zero');\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, 'SafeMath: modulo by zero');\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/OpynV2OTokenLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract OpynV2OTokenLike {\n    function getOtokenDetails()\n        external\n        view\n        virtual\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        );\n}\n"
    },
    "contracts/interfaces/OpynV2ControllerLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\npragma experimental ABIEncoderV2;\n\nenum ActionType {\n    OpenVault,\n    MintShortOption,\n    BurnShortOption,\n    DepositLongOption,\n    WithdrawLongOption,\n    DepositCollateral,\n    WithdrawCollateral,\n    SettleVault,\n    Redeem,\n    Call\n}\n\nstruct ActionArgs {\n    ActionType actionType;\n    address owner;\n    address secondAddress;\n    address asset;\n    uint256 vaultId;\n    uint256 amount;\n    uint256 index;\n    bytes data;\n}\n\nabstract contract OpynV2ControllerLike {\n    function operate(ActionArgs[] calldata _actions) external virtual;\n\n    function getPayout(address _otoken, uint256 _amount) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/OpynV2WhitelistLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract OpynV2WhitelistLike {\n    function isWhitelistedOtoken(address _otoken) external view virtual returns (bool);\n}\n"
    },
    "contracts/interfaces/UniswapV2Router02Like.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nabstract contract UniswapV2Router02Like {\n    function getAmountsIn(uint256 amountOut, address[] memory path)\n        public\n        view\n        virtual\n        returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/test-utils/SaviourRegistryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/SAFESaviourRegistryLike.sol';\n\ncontract SaviourRegistryMock is SAFESaviourRegistryLike {\n    function markSave(bytes32, address) external override {\n        // do nothing\n    }\n\n    function authorizeAccount(address _account, uint256 value) external {\n        authorizedAccounts[_account] = value % 2;\n    }\n}\n"
    },
    "contracts/test-utils/UniswapV2Router02Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/UniswapV2Router02Like.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol';\n\ncontract UniswapV2Router02Mock is UniswapV2Router02Like {\n    function getAmountsIn(uint256 amountOut, address[] memory path)\n        public\n        pure\n        override\n        returns (uint256[] memory amounts)\n    {\n        uint256[] memory returnedAmounts = new uint256[](path.length);\n\n        for (uint256 idx = 0; idx < path.length; ++idx) {\n            returnedAmounts[idx] = amountOut;\n        }\n\n        return returnedAmounts;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address,\n        uint256\n    ) external override returns (uint256[] memory amounts) {\n        uint256[] memory returnedAmounts = new uint256[](path.length);\n\n        for (uint256 idx = 0; idx < path.length; ++idx) {\n            returnedAmounts[idx] = amountOutMin;\n        }\n\n        ERC20Burnable(path[0]).transferFrom(msg.sender, address(this), amountIn);\n        ERC20Burnable(path[path.length - 1]).transfer(msg.sender, amountOutMin);\n\n        return returnedAmounts;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/test-utils/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract ERC20Mock is ERC20 {\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\n\n    function mint(address acc, uint256 am) public {\n        ERC20._mint(acc, am);\n    }\n\n    function burn(address acc, uint256 am) public {\n        ERC20._burn(acc, am);\n    }\n}\n"
    },
    "contracts/test-utils/OpynV2OTokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/OpynV2OTokenLike.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol';\n\ncontract OpynV2OTokenMock is OpynV2OTokenLike, ERC20Burnable {\n    address public controller;\n    address public collateralAsset;\n    address public underlyingAsset;\n    address public strikeAsset;\n    uint256 public strikePrice;\n    uint256 public expiryTimestamp;\n    bool public isPut;\n    address public owner;\n\n    constructor(\n        address _collateralAsset,\n        address _underlyingAddress,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) ERC20('oToken-TEST', 'OTEST') {\n        collateralAsset = _collateralAsset;\n        underlyingAsset = _underlyingAddress;\n        strikeAsset = _strikeAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        owner = msg.sender;\n    }\n\n    modifier ownerOnly() {\n        require(owner == msg.sender, 'not owner');\n        _;\n    }\n\n    function mint(address acc, uint256 am) public {\n        ERC20._mint(acc, am);\n    }\n\n    function burn(address acc, uint256 am) public {\n        ERC20._burn(acc, am);\n    }\n\n    function setCollateralAsset(address _collateralAsset) external ownerOnly {\n        collateralAsset = _collateralAsset;\n    }\n\n    function setUnderlyingAsset(address _underlyingAsset) external ownerOnly {\n        underlyingAsset = _underlyingAsset;\n    }\n\n    function setStrikeAsset(address _strikeAsset) public ownerOnly {\n        strikeAsset = _strikeAsset;\n    }\n\n    function setStrikePrice(uint256 _strikePrice) public ownerOnly {\n        strikePrice = _strikePrice;\n    }\n\n    function setExpiryTimestamp(uint256 _expiryTimestamp) public ownerOnly {\n        expiryTimestamp = _expiryTimestamp;\n    }\n\n    function setPut(bool _isPut) public ownerOnly {\n        isPut = _isPut;\n    }\n\n    function getOtokenDetails()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return (collateralAsset, underlyingAsset, strikeAsset, strikePrice, expiryTimestamp, isPut);\n    }\n}\n"
    },
    "contracts/test-utils/OpynV2ControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/OpynV2OTokenLike.sol';\nimport '../interfaces/OpynV2ControllerLike.sol';\nimport './OpynV2OTokenMock.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol';\n\ncontract OpynV2ControllerMock is OpynV2ControllerLike {\n    mapping(address => mapping(address => uint256)) public balances;\n    mapping(address => uint256) public redeemable;\n\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier ownerOnly() {\n        require(owner == msg.sender, 'not owner');\n        _;\n    }\n\n    modifier isRedeemable(address _otoken) {\n        require(redeemable[_otoken] == 1, 'not redeemable');\n        _;\n    }\n\n    function fundOtoken(\n        address _otoken,\n        address _collateralAsset,\n        uint256 _amount\n    ) external {\n        ERC20Burnable(_collateralAsset).transferFrom(msg.sender, address(this), _amount);\n        balances[_otoken][_collateralAsset] = balances[_otoken][_collateralAsset] + _amount;\n    }\n\n    function toggleRedeemable(address _otoken) external ownerOnly {\n        redeemable[_otoken] = (redeemable[_otoken] + 1) % 2;\n    }\n\n    function operate(ActionArgs[] calldata _actions) external override {\n        // check length is one and action is redeem then just send the tokens\n        require(\n            _actions.length == 1 && _actions[0].actionType == ActionType.Redeem,\n            'mock made for single type of calls'\n        );\n        require(redeemable[_actions[0].asset] == 1, 'not redeemable');\n        OpynV2OTokenLike otoken = OpynV2OTokenLike(_actions[0].asset);\n\n        (address collateralAsset, , , , , ) = otoken.getOtokenDetails();\n\n        require(_actions[0].amount <= ERC20Burnable(address(otoken)).balanceOf(msg.sender), 'too much redeemed');\n\n        uint256 amountToSend =\n            (_actions[0].amount / ERC20Burnable(address(otoken)).totalSupply()) *\n                (balances[address(otoken)][collateralAsset]);\n\n        require(amountToSend <= balances[address(otoken)][collateralAsset], 'not enough collateral');\n\n        balances[address(otoken)][collateralAsset] = balances[address(otoken)][collateralAsset] - amountToSend;\n\n        ERC20Burnable(collateralAsset).transfer(_actions[0].secondAddress, amountToSend);\n\n        OpynV2OTokenMock(address(otoken)).burn(msg.sender, _actions[0].amount);\n    }\n\n    function getPayout(address _otoken, uint256 _amount) public view override isRedeemable(_otoken) returns (uint256) {\n        (address collateralAsset, , , , , ) = OpynV2OTokenLike(_otoken).getOtokenDetails();\n        return ((_amount * balances[_otoken][collateralAsset]) / (ERC20Burnable(_otoken).totalSupply()));\n    }\n}\n"
    },
    "contracts/test-utils/OpynV2WhitelistMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/OpynV2WhitelistLike.sol';\n\ncontract OpynV2WhitelistMock is OpynV2WhitelistLike {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier ownerOnly() {\n        require(msg.sender == owner, 'not owner');\n        _;\n    }\n\n    mapping(address => uint256) public whitelist;\n\n    function toggleWhitelist(address _otoken) external ownerOnly {\n        whitelist[_otoken] = (whitelist[_otoken] + 1) % 2;\n    }\n\n    function isWhitelistedOtoken(address _otoken) external view override returns (bool) {\n        return whitelist[_otoken] == 1;\n    }\n}\n"
    },
    "contracts/test-utils/SafeManagerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/GebSafeManagerLike.sol';\n\ncontract SafeManagerMock is GebSafeManagerLike {\n    mapping(uint256 => address) private _safes;\n    mapping(uint256 => address) private _owners;\n\n    function setSafe(\n        uint256 _id,\n        address _handler,\n        address _owner\n    ) public {\n        _safes[_id] = _handler;\n        _owners[_id] = _owner;\n    }\n\n    function safes(uint256 id) public view override returns (address) {\n        return _safes[id];\n    }\n\n    function ownsSAFE(uint256 id) public view override returns (address) {\n        return _owners[id];\n    }\n\n    mapping(address => mapping(uint256 => mapping(address => uint256))) private _safeCan;\n\n    function toggleSafeCan(\n        address owner,\n        uint256 id,\n        address allowed\n    ) public {\n        _safeCan[owner][id][allowed] = (_safeCan[owner][id][allowed] + 1) % 2;\n    }\n\n    function safeCan(\n        address owner,\n        uint256 id,\n        address allowed\n    ) public view override returns (uint256) {\n        return _safeCan[owner][id][allowed];\n    }\n}\n"
    },
    "contracts/test-utils/PriceFeedLikeMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/PriceFeedLike.sol';\n\ncontract PriceFeedMock is PriceFeedLike {\n    address private _priceSource;\n\n    function setPriceSource(address _psource) public {\n        _priceSource = _psource;\n    }\n\n    function priceSource() public view override returns (address) {\n        if (_priceSource == address(0)) {\n            return address(this);\n        }\n        return _priceSource;\n    }\n\n    uint256 private result;\n    bool private validity;\n\n    function setResultWithValidity(uint256 _result, bool _validity) public {\n        result = _result;\n        validity = _validity;\n    }\n\n    function getResultWithValidity() external view override returns (uint256, bool) {\n        return (result, validity);\n    }\n}\n"
    },
    "contracts/test-utils/SafeEngineMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/SAFEEngineLike.sol';\n\ncontract SafeEngineMock is SAFEEngineLike {\n    // --- Data ---\n    struct CollateralType {\n        // Total debt issued for this specific collateral type\n        uint256 debtAmount; // [wad]\n        // Accumulator for interest accrued on this collateral type\n        uint256 accumulatedRate; // [ray]\n        // Floor price at which a SAFE is allowed to generate debt\n        uint256 safetyPrice; // [ray]\n        // Maximum amount of debt that can be generated with this collateral type\n        uint256 debtCeiling; // [rad]\n        // Minimum amount of debt that must be generated by a SAFE using this collateral\n        uint256 debtFloor; // [rad]\n        // Price at which a SAFE gets liquidated\n        uint256 liquidationPrice; // [ray]\n    }\n    struct SAFE {\n        // Total amount of collateral locked in a SAFE\n        uint256 lockedCollateral; // [wad]\n        // Total amount of debt generated by a SAFE\n        uint256 generatedDebt; // [wad]\n    }\n\n    // Data about each collateral type\n    mapping(bytes32 => CollateralType) private _collateralTypes;\n    // Data about each SAFE\n    mapping(bytes32 => mapping(address => SAFE)) private _safes;\n    mapping(address => mapping(address => uint256)) private _safeRights;\n\n    function safeRights(address owner, address user) public view override returns (uint256) {\n        return _safeRights[owner][user];\n    }\n\n    function toggleSafeRights(address owner, address user) public {\n        _safeRights[owner][user] = (_safeRights[owner][user] + 1) % 2;\n    }\n\n    function setCollateralType(\n        bytes32 _collateralType,\n        uint256 _debtAmount,\n        uint256 _accumulatedRate,\n        uint256 _safetyPrice,\n        uint256 _debtCeiling,\n        uint256 _debtFloor,\n        uint256 _liquidationPrice\n    ) public {\n        _collateralTypes[_collateralType] = CollateralType({\n            debtAmount: _debtAmount,\n            accumulatedRate: _accumulatedRate,\n            safetyPrice: _safetyPrice,\n            debtCeiling: _debtCeiling,\n            debtFloor: _debtFloor,\n            liquidationPrice: _liquidationPrice\n        });\n    }\n\n    function collateralTypes(bytes32 _collateralType)\n        public\n        view\n        override\n        returns (\n            uint256 debtAmount, // [wad]\n            uint256 accumulatedRate, // [ray]\n            uint256 safetyPrice, // [ray]\n            uint256 debtCeiling, // [rad]\n            uint256 debtFloor, // [rad]\n            uint256 liquidationPrice // [ray]\n        )\n    {\n        CollateralType memory ct = _collateralTypes[_collateralType];\n        return (ct.debtAmount, ct.accumulatedRate, ct.safetyPrice, ct.debtAmount, ct.debtFloor, ct.liquidationPrice);\n    }\n\n    function setSafe(\n        bytes32 _collateralType,\n        address _safeId,\n        uint256 _lockedCollateral,\n        uint256 _generatedDebt\n    ) public {\n        _safes[_collateralType][_safeId] = SAFE({lockedCollateral: _lockedCollateral, generatedDebt: _generatedDebt});\n    }\n\n    function safes(bytes32 _collateralType, address _safeId)\n        public\n        view\n        override\n        returns (\n            uint256 lockedCollateral, // [wad]\n            uint256 generatedDebt // [wad]\n        )\n    {\n        SAFE memory s = _safes[_collateralType][_safeId];\n        return (s.lockedCollateral, s.generatedDebt);\n    }\n\n    function modifySAFECollateralization(\n        bytes32 collateralType,\n        address safe,\n        address collateralSource,\n        address debtDestination,\n        int256 deltaCollateral, // [wad]\n        int256 deltaDebt // [wad]\n    ) external override {\n        // do nothing zzzZZZzzz\n    }\n}\n"
    },
    "contracts/test-utils/OracleRelayerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.7 <=0.7.6;\n\nimport '../interfaces/OracleRelayerLike.sol';\n\ncontract OracleRelayerMock is OracleRelayerLike {\n    // --- Data ---\n    struct CollateralType {\n        // Usually an oracle security module that enforces delays to fresh price feeds\n        address orcl;\n        // CRatio used to compute the 'safePrice' - the price used when generating debt in SAFEEngine\n        uint256 safetyCRatio;\n        // CRatio used to compute the 'liquidationPrice' - the price used when liquidating SAFEs\n        uint256 liquidationCRatio;\n    }\n\n    // Data about each collateral type\n    mapping(bytes32 => CollateralType) private _collateralTypes;\n\n    uint256 private _redemptionPrice;\n\n    function setCollateralType(\n        bytes32 _collateral,\n        address _orcl,\n        uint256 _safetyCRatio,\n        uint256 _liquidationCRatio\n    ) public {\n        _collateralTypes[_collateral] = CollateralType({\n            orcl: _orcl,\n            safetyCRatio: _safetyCRatio,\n            liquidationCRatio: _liquidationCRatio\n        });\n    }\n\n    function collateralTypes(bytes32 _collateral)\n        public\n        view\n        override\n        returns (\n            address,\n            uint256,\n            uint256\n        )\n    {\n        CollateralType memory ct = _collateralTypes[_collateral];\n        return (ct.orcl, ct.safetyCRatio, ct.liquidationCRatio);\n    }\n\n    function liquidationCRatio(bytes32 collateralType) public view override returns (uint256) {\n        return _collateralTypes[collateralType].liquidationCRatio;\n    }\n\n    function setRedemptionPrice(uint256 __redemptionPrice) public {\n        _redemptionPrice = __redemptionPrice;\n    }\n\n    function redemptionPrice() public view override returns (uint256) {\n        return _redemptionPrice;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}